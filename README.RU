BerkeleyDB для языка программирования D

Данный пакет обеспечивает 2 версии интерфейса к библиотеке BerkeleyDB для D:

- Первая версия повторят С-интерфейс, целиком транслируется из заголовочных
  файлов BerkeleyDB и потому может быть легко перегенерирован для новой версии
  BerkeleyDB. Также при изменениях в языке D потребуется не так много
  изменений чтобы починить генерацию этого интерфейса.
  Уже сгенерированный файл для версии BerkeleyDB 6.1.26.NC находится 
  по пути "berkeleydb/c.d".
  Генератор - AWK-программа bdb2d.awk.
  Чтобы перегенерировать интерейс достаточно изменить в скрипте config.sh
  путь к исходникам  Berkeleydb с "~/Programs/db-6.1.26.NC" на ваш 
  путь. После чего запустите "./bdb2d.sh"

- Вторая версия старается больше походить на то, что можно назвать
  D-интерфейсом. Ниже описывается основная идея интерфейса.

Интерфейс состоит из:
- 10 классов повторяющих соответствующие структуры BDB: 
  Dbc, DbChannel, Db, DbEnv, DbLogc, DbMpoolfile, DbSequence, DbSite,
  DbStream, DbTxn.
- 7 классов исключений, 5 из которых повторяют исключения C++ интерфейса BDB:
  DbException, DbWrongUsingException, DbDeadlockException
  DbLockNotGrantedException, DbMemoryException, DbRepHandleDeadException,
  DbRunRecoveryException
- структуры Dbt и ещё 3-х сопутствующих структур:
  UserMemDbt, BulkDbt, RecnoBulkDbt

Интерфейсы классов повторяют интерфейсы BDB, но при этом руководствуется
следующими идеями:
1) Методы вроде db_create/db_env_create в этой библиотеке
   заменяют конструкторы соответствующего класса.
2) В остальном имена методов полностью совпадают
3) Вместо "const char*" везде используются string
4) Вместо других массивов таких как например DB_LOCKREQ* аргумент
   в функции DB_ENV->lock_vec с указанием длины в отдельном аргументе
   используются массивы D, такие как DbLockreq[] DbEnv.lock_vec содержащего
   как указатель так и длину в одном аргументе
5) Вместо кодов ошибок используются исключения. Большинство функций
   при этом превратились в void-методы. Исключения составляют такие функции
   как db.get, которые могут возвращать коды не считающимися ошибками
   (DB_KEYEMPTY, DB_NOTFOUND и т.д.). Полный список таких функций можно
   посмотреть в реализации функции DbRetCodeToException
   (файл berkeleydb/dbexception.d)
6) Естественно первый аргумент - указатель на класс исчез
   (как например DB_ENV *dbenv в примере из пункта 7)
7) Когда функция возвращает единственное значение, аргумент-указатель
   превращается в возвращаемое значение функции. Например, функция
   int DB_ENV->get_open_flags(DB_ENV *dbenv, u_int32_t *flagsp);
   Превратилась в
   uint32_t DbEnv.get_open_flags()
   Т.е. функция теперь возвращает flags вместо кода ошибки
8) Функции принимающие или возвращающие по 2 аргумента gbytes, bytes
   помимо копирующего интерфейса с 2 аргументами имеют
   интерфейс с одним 64-битным аргументом bytes. Например:
   void DbEnv.set_memory_max(uint32_t gbytes, uint32_t bytes)
   void DbEnv.set_memory_max(uint64_t bytes)
   и
   void DbEnv.get_memory_max(ref uint32_t gbytes, ref uint32_t bytes)
   uint64_t DbEnv.get_memory_max()
9) Callback'и также используют D-аргументы, например "DbEnv" вместо "DB_ENV*",
   строки string вместо указателей char* и т.д.
10) Последний аргумент flags может быть опущен если он равен нулю.

Структура Dbt опуская методы объявлена так:

struct Dbt
{
	DBT dbt;
	alias dbt this;
}

Это значит что вы можете использовать тип Dbt обращаясь к его полям также
как вы делаете с DBT. Кроме того можно безболезненно преобразовать cast'ом
(DBT*) в (Dbt*) и обратно. И даже массив Dbt[] можно смело преобразовать
в массив в C-стиле инструкцией cast(DBT*)Dbt.ptr.
Но помимо этого Dbt умеет например так:

    string hello = "Hello, world!";

	Dbt dbt = hello; //dbt.data и dbt.size заполнены одним присвоением.
	assert(dbt.size == hello.length);

	assert(dbt.to!string() == "Hello, world!"); //обратное преобразование 
	assert(dbt.to!string() is "Hello, world!");

	struct S
	{
		int a;
		byte b;
	}
	
	S s;
	s.a = 5000;
	s.b = 22;

	Dbt dbt_struct;
    dbt_struct = s; // снова dbt_struct.data и dbt_struct.size одной инструкцией
	assert( dbt_struct.size == s.sizeof );
	assert( dbt_struct.to!S() == s ); //Обратно

	S *ps = dbt_struct.to!(S*)(); //А можно преобразовать и в указатель
	assert( *ps == s );
	assert( ps is &s );

Аналогично используется UserMemDbt, но ему передаётся в конструктуре
размер выделяемого буфера. В отличие от Dbt при присвоении значения 
в UserMemDbt будет скопировано присвояемое значение в буфер, а не просто 
присвоена в dbt.data ссылка на него.
Указатель UserMemDbt* может быть cast'ован в (Dbt*) и обратно.

BulkDbt/RecnoBulkDbt могут использоваться для массовых операций вставки/
получения. Оба типа могут быть cast'ованы в (Dbt*) но не наоборот.
Для обратного преобразования используйте конструкторы 
BulkDbt(ref Dbt dbt) и RecnoBulkDbt(ref Dbt dbt).
Для примеров использования смотрите unittest'ы в berkeleydb/dbt.d

Для примера использования библиотеки смотрите пример в директории
transactions_test

Ошибки библиотеки:
1) Интерфейс иногда может быть не последовательным. Например
   иногда транслировать указатель в ref-аргумент, а иногда оставлять
   указателем.
2) Некоторые функции такие как DbEnv.memp_stat кажется могут приводить
   к утечкам памяти.
3) Если для базы данных Db метод close вызван явно, а для её курсора Dbc 
   не вызван ранее, то он будет вызван в деструкторе, что приведёт к ошибке.
